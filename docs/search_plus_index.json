{"./":{"url":"./","title":"Introduction","keywords":"","body":"CSE 1320 The C Programming Language by Brian Kernighan and Dennis Ritchie "},"Lecture1.html":{"url":"Lecture1.html","title":"Basic C Language","keywords":"","body":"Basic C Language "},"C1.html":{"url":"C1.html","title":"Overview of C","keywords":"","body":"Overview of C "},"C2.html":{"url":"C2.html","title":"Overview constants, Data Types","keywords":"","body":"Data Types Variables Constants Operators Expressions Variables and Constants Variables and constants are the basic data objects manipulated in a program. All variables must be declared before use, although certain declarations can be made implicitly by content. [info] Primative Data Types char        a single byte, capable of holding one character in the local character set int           an integer, typically reflecting the natural size of integers on the host machine float        single-precision floating point double    double-precision floating point [info] signed and unsigned forms Unsigned    target type will have unsigned representation Unsigned char: 0~255 Signed char: -128~127 The max unsigned integer is 2^31 If add two unsigned integer larger than 2^31, it will overflow, results will be mod by 2^32 The max signed integer is 2^32 If add two signed integer larger than 2^31, it will overflow, results will be negative number Signed        target type will have signed representation [warning] String String is not primative data type. String constants would be concatenated at compile time. C uses “array” of chars for storing a string. String must ends with a special character '\\0' char str[] = { 'F', 'o', 'o', 'b', 'a', 'r', '\\0' } You would define a string like, in this way the NULL character is hidden char str[] = “Foobar” You would use a char* “pointer”, in this way the NULL character is hidden char *str = “Foobar” Certain characters can be represented in character and string constants by escape sequences. Escape sequence Character represented Escape sequence Character represented \\a alert character \\\\ backslash \\b backspace \\? question mark \\f formfeed \\' single quote \\n newline \\\" double quote \\r carriage return \\ooo octal number \\t horizontal tab \\xhh hexadecimal number \\v vertical tab Operators and expressions Arithmetic Operators The binary arithmetic operators are addition +, subtraction, - multiplication *, division /, and the modulus operator %. Relational and Logical Operators The relational operators are >, >=, , , ==, and !=. The logical operators are && and ||. Increment and Decrement Operators The increment operator ++ adds 1 to its operand, while the decrement operator -- subtracts 1. These operators can be placed before (prefix) or after (postfix) a variable. Bitwise Operators The bitwise operators are bitwise AND &, bitwise inclusive OR |, bitwise exclusive OR ^, left shift , right shift >>, and one's complement ~. Assignment Operators and Expressions The assignment operator = assigns a value to a variable. Conditional Expressions The conditional expression is (condition_is_true) ? do_if_true : do_if_false;. In the expression expr1 ? expr2 : expr3, the expression expr1 is evaluated first. If it is true, then the expression expr2 is evaluated, and that is the value of the conditional expression. Otherwise expr3 is evaluated, and that is the value. Only one of expr2 and expr3 is evaluated. "},"C3.html":{"url":"C3.html","title":"Conditionals and loops","keywords":"","body":"Conditionals and loops Theif statements The conditional expression The switch statement The loops if statement The syntax is if (condition_is_true) do_something; Sometimes we wish to do more than one thing in response to a condition being true. We would use braces. if (condition_is_true){ do_something; do_something; } Sometimes we wish to have a second conditional statement in response to the first condition being true. It's a good idea to use braces when there are nested ifs. if (condition_is_true) if(condition_is_true){ do_something; } Sometimes we wish to do one thing if a condition is true but another if the condition is false. if (condition_is_true) do_something; else do_something_else; else if statement What happens in the else if statement is that one of the statement is executed, depending on which of the condition is true. Each condition is tested in turn, and if one is true, the corresponding statement is executed, and the rest are skipped. if none of the condition is true, we fall through to the last one. The syntax is if (expression) statement else if (expression) statement else if (expression) statement else if (expression) statement else statement [info] else if statement This sequence of if statements is the most general way of writing a multi-way decision. The expressions are evaluated in order; if an expression is true, the statement associated with it is executed, and this terminates the whole chain. As always, the code for each statement is either a single statement, or a group of them in braces. Conditional expressions Instead of an if else statement, we can use the conditional expression operator: (condition_is_true) ? do_if_true : do_if_false; a = (condition_is_true) ? b : c switch statement An if else statement is used for binary decisions–those with two choices. Sometimes there are more than two choices. The switch statement is a multi-way decision that tests whether an expression matches one of a number of constant integer values, and branches accordingly. switch (expression) { case const-expr: statements case const-expr: statements default: statements } [warning] Notes on the use of the switch statement The labels must be integers. The default line is optional. Once the matching label is found, that statement and each following statement will be executed. Loops 1.while loops There are many occasions in which we don’t know in advance how many times the loop should repeat, but we do know under what conditions the loop should terminate. while(test) { do_something; } 2.for loops for(expression1; expression2; expression3) do_something; [info] expression expression1 initializes the counter. expression2 is the condition for stopping. expression3 is the method of incrementing the counter at the end of the loop. 3.do-while loops The do while loop differs from the while loop in that the body will be visited once before the test is evaluated. do { do_something; } while(test) 4.continue and break We would use continue to jump to the very end of the current loop. We would use break to jump out of the current loop completely. "},"C5.html":{"url":"C5.html","title":"Pointers and arrays","keywords":"","body":"Pointers and arrays Pointers Arrays Multidimensional Arrays Pointers and arrays Pointer Addresses in Memory The address of the variable is stored in the memory. We would use the address operator, an ampersand &, to return its address. The format specifier for address is %p. Number Systems Common Name Base Digits binary 2 01 octal 8 01234567 decimal 10 0123456789 hexadecimal 16 0123456789ABCDEF 3.Pointers A pointer is a variable whose contents are the address of another variable. Let's say that the integer is int number = 3; the content of number is 3 and the address of number is &number. We would create a pointer int *numberPtr; and copy the address of number to the pointer numberPtr = &number. The content of numberPtr is the address of number. We would use the dereference operator, an asterisk *, to modify its locations in memory. Let's say that the integer is int number = 3; and the pointer is int* numberPtr;. We would copy the address of the number to the pointer numberPtr = &number. The content of number is number, which is 3. The content of number using pointer is *numberPtr, which is 3. We would change waht the pointer points to *numberPtr = 6. The content of number will be 6. Pointer numberPtr has its own type, a type of int* or pointer-to-int. We would increment the address in the pointer numberPtr++. Pointers to pointers Pointers can contain the address of another pointer. int number = 5;, int* numberPtr = &number, int** Ptr2 = &numberPtr;. We would compare the addresses stored in pointers if(numberPtr1 == numberPtr2). We would compare the values of the variables that pointers point to if(*numberPtr1 == *numberPtr2). We would initialize the pointer to NULL, int *numberPtr;, numberPtr = NULL. 4.Pointers and Functions Pointers allow us to use a process called pass by reference, in which we will be able to change the value of the original variable. We do this by passing the variable’s address to the function. 5.Arrays of Pointers A pointer is a variable type and we can have an array of pointers just as we have had arrays of other variable types. Array Array is a variable that can hold more than one value. We would define an array of size 10 int a[10]. The array a[10] will hold 10 integer numbers. We could provide the specific array values a[0] = 1, a[1] = 2, etc. We would also declare and initialize the array at the same time int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}. The first element of the array is a[0], the second element is a[1], etc. [info] Array Each element of the array will be of the same type. Array indices began at 0. The initialized values will be at the beginning of the array. The remaining values will be initialized to zero. [warning] Array out of bounds A common error is the “array out of bounds” error that occurs when the index goes beyond the declared size. The value outside the assigned range will be changed. Multidimensional Arrays 2D array int a[rows][columns] = { {1, 2, 3}, {4, 5, 6} }; 3D array int a[][][]; [warning] 1D and 2D arrays differences When declaring a 2D array, the number of columns is required. Pointers and arrays 1.Pointers and arrays are closely linked in C. /*array name evaluates to the address of * the first element in the array*/ #include int main() { int num[4] = {1, 2, 3, 4}; printf(\"The address of num[0] is %p\\n\", num); printf(\"The content of num[0] is %d\\n\", *num); return 0; } [info] Arrays The array name num is the address of the first element, and *num is the content of the first element. /*array name evaluates to the address of * the first element in the array*/ #include int main() { int num[4] = {1, 2, 3, 4}; int* numPtr = num; int* firstPtr = &num[0]; printf(\"The address of num[0] using numPtr is %p\\n\", numPtr); printf(\"The content of num[0] using numPtr is %d\\n\", *numPtr); printf(\"The address of num[0] using firstPtr is %p\\n\", firstPtr); printf(\"The content of num[0] using firstPtr is %d\\n\", *firstPtr); return 0; } [info] Pointers and arrays Let's say that firstPtr is the pointer to the integer num[0], declared as int* firstPtr;. firstPtr = &num[0] is the address of num[0]. *firstPtr is the contents of num[0]. 2.We would increment the address to move through the array. #include int main() { int num[4] = {1, 2, 3, 4}; printf(\"The address of num[1] is %p\\n\", num + 1); printf(\"The content of num[1] is %d\\n\", *(num + 1)); return 0; } #include int main() { int num[4] = {1, 2, 3, 4}; int* numPtr = num; int* firstPtr = &num[0]; printf(\"The address of num[1] using numPtr is %p\\n\", numPtr + 1); printf(\"The content of num[1] using numPtr is %d\\n\", *(numPtr + 1)); printf(\"The address of num[1] using firstPtr is %p\\n\", firstPtr + 1); printf(\"The content of num[1] using firstPtr is %d\\n\", *(firstPtr + 1)); for (int i = 0; i [info] Pointer arithmetic Let's say that firstPtr is the pointer to the integer num[0], declared as int* firstPtr;. firstPtr + i is the address of num[i]. *(firstPtr + i) is the contents of num[i]. #include int main() { char charArray[] = {'a', 'b', 'c', 'd', 'e'}; int intArray[] = {1, 2, 3, 4, 5}; printf(\"charArray intArray\\n\"); printf(\"------------------------------\\n\"); for (int i = 0; i [info] Pointer arithmetic Pointer arithmetic handles the task of determining the address of the next element in the array. 3.Arrays and functions [info] Arrays as function parameters We would pass the address of the first element of an array int num[] = {1, 2, 3}; function(num);. The subscript style of the array as function parameters void function(int data[]){}. The pointer style of the array as function parameters void somefunction(int* data){}. 4.2D Arrays #include int main() { int data[2][3] = {{1, 2, 3}, {6, 7, 8}}; printf(\"The address of data is %p\\n\", data); printf(\"The address of row 0 is %p\\n\", *data); printf(\"The value of the data[0][0] is %d\\n\", **data); return 0; } [info] 2D Arrays Returning the address of any element of any row *(array_name + row) + column. Returning the value of any element of any row *(*(array_name + row) + column). 5.Pointers to 2D arrays #include int main() { int data[2][3] = {{1, 2, 3}, {6, 7, 8}}; int *ptrOne = &data[0][0]; int (*ptrTwo)[3] = data; printf(\"The first element of array is %p\\n\", ptrOne); printf(\"The first element of array is %p\\n\", ptrTwo[0]); return 0; } [info] 2D Arrays We can also create a pointer to a 2D array. The int *ptrOne = &data[0][0]; allows pointer arithmetic based on individual ints. The int (*ptrTwo)[3] = data; allows pointer arithmetic based on row/column values for accessing the array elements. 6.We can have an array whose members are pointers. 7.The typical use for arrays of pointers is not with numeric types, such as int or double, but with strings. "},"C6.html":{"url":"C6.html","title":"Strings","keywords":"","body":"Strings char ASCII Strings char A char is a one byte integer type typically used for storing characters. char letter = 'A'; [info] Character We enclose the character in single quotes, not double quotes. ASCII Plain text is often stored in a format called ASCII. char letter = 'a'; char decimal = 97; The letters A–Z have ASCII values of 65–90 while a–z have values of 97–122. char uppercase = 'A'; char lowercase; lowercase = uppercase + 32; Strings C does not have a string type. Instead, we use an array of chars for storing a string. char str[] = { 'F', 'o', 'o', 'b', 'a', 'r', '\\0' } char myName[] = \"foobar\"; char *myName = \"foobar\"; "},"C4.html":{"url":"C4.html","title":"Functions and program structure","keywords":"","body":"Functions and program structure Functions Each function definition has the general form return_type function_name(input_type variable_name) { /* something happens here */ } int addNumbers(int number1, int number2) { int sum = number1 + number2; return sum; } [info] Functions Variable The variable names in the function definition do not have to match the names in the function call. We would declare variables in our function. We would call other functions in our function. Return We would use return keyword to return a value. We would use void if we are not passing or not returning anything. We can pass or receive any types of variables. Arrays We can pass arrays to functions just as we do with other variable types. There is a significant difference between passing variables to functions and passing arrays to functions. When passing a cariable by value, a copy of the variable is used in the function. The changes to the variables will not affect the original. When passing an array to a function, we are actually passing the address of the array. The changes to the array will affect the original. When passing 2D arrays as paramerters, the number of the columus is required. Declarations Function code would be before main. Function declaration would be before main. Including functions To use functions in the Standard C Library stdio.h. We could place our own functions in their own file and use them in our programs Variable scope Scope Visibility of variable. Local variable Variables declared within a function block are local variables and they are known only to that function. Variables declared outside the function are unknown to the function. Global variable A global variable is a variable that is declared outside all functions. The scope of a global variable is the file. All functions can use the global variable. Let's say that the first function is main() and additional functions are defined after main(). The variables declared above main() are global variables. Access a global variable in another file extern. Swap Function #include #include void swap(int *a, int *b) { int tmp; tmp = *a; *a = *b; *b = tmp; } void swapWithoutTemp(int *a, int *b) { *a = *a ^ *b; *b = *a ^ *b; *a = *a ^ *b; // *b = *a ^ *b; // *a = *a ^ *b; // *b = *a ^ *b; } int main() { int a = 1; int b = 2; // // Swap // // Declare tmp and store a to tmp // int tmp; // tmp = a; // // Copy b to a // a = b; // // Copy tmp to b // b = tmp; // printf(\"a %d, b %d\", a, b); // swap(&a, &b); swapWithoutTemp(&a, &b); printf(\"a %d, b %d\", a, b); } "},"C7.html":{"url":"C7.html","title":"Linked List","keywords":"","body":"Linked List Malloc and Free newNode = (Node *) malloc(sizeof(Node)); The malloc statement first looks at the amount of memory available on the heap and asks, \"Is there enough memory available to allocate a block of memory of the size requested?\" The amount of memory needed for the block is known from the parameter passed into malloc. If there is not enough memory available, the malloc function returns NULL. Otherwise malloc proceeds. If memory is available on the heap, the system \"allocates\" or \"reserves\" a block from the heap of the size specified. The system reserves the block of memory so that it isn't accidentally used by more than one malloc statement. The system then places into the pointer variable (newNode, in this case) the address of the reserved block. The pointer variable itself contains an address. The allocated block is able to hold a value of the type specified, and the pointer points to it. Pointer Types We would create pointer types like this: typedef int *IntPointer; ... IntPointer p; This is the same as saying: int *p; Singly Linked List #include #include #include typedef struct Node { int data; struct Node *next; } Node; // Declare the head pointer and initialize the head pointer Node *head = NULL; // Declare the currentSize and initialize the currentSize int currentSize = 0; // Add first void addFirst(int data) { // Create a new node Node *newNode; newNode = (Node *) malloc(sizeof(Node)); newNode->data = data; newNode->next = NULL; // Let the newNode.next point to the head pointer newNode->next = head; // Move the head pointer head = newNode; // Increment the currentSize currentSize++; } void search(int data) { // Declare the tmpPointer and store the address of head to the tmpPointer Node *tmpPointer = head; // Declare foundData bool foundData = false; // Declare count and initialize the count int count = 0; // Move the tmpPointer for (int i = 0; i data == data) { // Print the data and the currentSize printf(\"Found %d at index %d\\n\", tmpPointer->data, count); // Let foundData to be true foundData = true; } // Increment the count count++; // Move the tmpPointer tmpPointer = tmpPointer->next; } // If the data is not in the list if (foundData == false) { printf(\"The data is not in the list.\\n\"); } } // Insert node at a particular place based on the index // Insert node at the index void insert(int data, int index) { // Check if the index is valid if (index currentSize - 1) { printf(\"Index out of range.\\n\"); return; } // If the index is 0 // Call addFirst if (index == 0) { addFirst(data); return; } // create a pointer type typedef Node *Ptr; // Copy the head pointer and store the address to tmpPointer // Node *tmpPointer = head; Ptr tmpPointer; tmpPointer = head; // Create the newNode Ptr newNode; newNode = (Node *) malloc(sizeof(Node)); newNode->data = data; newNode->next = NULL; // Move the tmpPointer to index - 1 for (int i = 0; i next; } // Let the newNode.next point to the current node newNode->next = tmpPointer->next; // Let the prevNode.next point to the newNode tmpPointer->next = newNode; // Increment the currentSize currentSize++; } // Insert it before a node which has value equal to the input value // Insert node at data void insertNode(int newData, int dataInList) { // Define a pointer type typedef Node *Ptr; // Copy the head pointer and store the address to the tmpPointer Ptr tmpPointer = head; // Declare prevNode Ptr prevNode = NULL; // Create the newNode Ptr newNode; newNode = (Node *) malloc(sizeof(Node)); newNode->data = newData; newNode->next = NULL; // If newData == head.data call addFirst if (dataInList == head->data) { addFirst(newData); return; } // Move the tmpPointer to the last node while (tmpPointer != NULL) { // Move the tmpPointer to the dataInList if (tmpPointer->data == dataInList) { // Let the newNode.next point to the tmpPointer newNode->next = tmpPointer; // Let the prevNode.next point to the newNode prevNode->next = newNode; // Increment the currentSize currentSize++; return; } // Move the prevNode and the tmpPointer // let the prevNode point to the tmpPointer prevNode = tmpPointer; // Move the tmpPointer tmpPointer = tmpPointer->next; } // If the data is not in the list printf(\"The data %d is not in the list.\\n\", dataInList); } int removeFirst() { // If the linked list is empty if (currentSize == 0) { return (int) NULL; } // Declare the removedData and store the head.data to the removedData int removedData = head->data; // Move the head pointer head = head->next; // Decrement the currentSize currentSize--; // Return the removedData return removedData; } // Remove node at data void delete(int dataInList) { // If the linked list is empty if (currentSize == 0) { return; } // If the dataInList is the first data // Call removeFirst if (head->data == dataInList) { removeFirst(); return; } // Define a pointer type typedef Node *Ptr; // Copy the head pointer and store the address to the tmpPointer Ptr tmpPointer = head; // Move the tmpPointer to the second last node while (tmpPointer->next != NULL) { // Move the dataInList to the previous node if (tmpPointer->next->data == dataInList) { // Let the tmpPointer.next point to the tmpPointer.next.next tmpPointer->next = tmpPointer->next->next; // Decrement the currentSize currentSize--; return; } // Move the tmpPointer tmpPointer = tmpPointer->next; } // If the data is not in the list printf(\"The data %d is not in the list.\\n\", dataInList); } void show() { // Declare the tmpPointer and store the address of head to the tmpPointer Node *tmpPointer = head; // Move the head pointer for (int i = 0; i data); // Move the tmpPointer tmpPointer = tmpPointer->next; } } int main() { addFirst(100); addFirst(200); show(); printf(\"\\n\"); insert(300, 1); show(); printf(\"\\n\"); insertNode(400, 100); show(); printf(\"\\n\"); delete(400); show(); printf(\"\\n\"); search(100); return 0; } Tutorial Singly Linked List Doubly Linked List Circular Linked List Stacks Queues Interview Questions Here are some questions from interviews for you to practice Write code to remove duplicates from an unsorted linked list. FOLLOW UP How would you solve this problem if a temporary buffer is not allowed? You have two numbers represented by a linked list, where each node contains a single digit.The digits are stored in reverse order, such that the 1’s digit is at the head of the list.Write a function that adds the two numbers and returns the sum as a linked list. EXAMPLE Input: (3 -> 1 -> 5) + (5 -> 9 -> 2) Output: 8 -> 0 -> 8 Given a circular linked list, implement an algorithm which returns node at the beginning of the loop. DEFINITION Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list. EXAMPLE input: A -> B -> C -> D -> E -> C [the same C as earlier] output: C "},"C8.html":{"url":"C8.html","title":"Stack","keywords":"","body":"Stack #include #include #define CAPACITY 100 typedef struct Stack { int data[CAPACITY]; int currentSize; } Stack; Stack s; //struct Stack s; void push(int data) { // Add data to stack s.data[s.currentSize] = data; // Increment the currentSize s.currentSize++; } int pop() { // Declare removedData and store the last data to the removedData int removedData = s.data[s.currentSize - 1]; // Let the last data equal to NULL s.data[s.currentSize] = (int) NULL; // Decrement the currentSize s.currentSize--; // Return the removedData return removedData; } void show() { for (int i = 0; i typedef struct Define struct Declare struct Initialize struct #include #include #define CAPACITY 100 // Define a struct typedef struct Stack { int data[CAPACITY]; int currentSize; } Stack; void push(Stack *s, int data) { // Add data to stack s->data[s->currentSize] = data; // Increment the currentSize s->currentSize++; } int pop(Stack *s) { // Declare removedData and store the last data to the removedData int removedData = s->data[s->currentSize - 1]; // Let the last data equal to NULL s->data[s->currentSize] = (int) NULL; // Decrement the currentSize s->currentSize--; // Return the removedData return removedData; } void show(Stack *s) { for (int i = 0; i currentSize; ++i) { printf(\"%d \", s->data[i]); } } int main() { // Declare a variable and initialize a variable Stack s = {.currentSize = 0}; // // Declare a variable // Stack s; // // Initialize a variable // s.currentSize = 0; push(&s, 100); push(&s, 200); push(&s, 300); printf(\"%d\\n\", pop(&s)); show(&s); printf(\"\\n\"); // Declare a struct and initialize a struct struct Stack ss = {.currentSize = 0}; // // Declare a struct // struct Stack ss; // // Initialize a struct // ss.currentSize = 0; push(&ss, 10); push(&ss, 20); push(&ss, 30); printf(\"%d\\n\", pop(&ss)); show(&ss); } "}}