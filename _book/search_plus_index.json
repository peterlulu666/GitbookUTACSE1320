{"./":{"url":"./","title":"Introduction","keywords":"","body":"CSE 1320 The C Programming Language by Brian Kernighan and Dennis Ritchie "},"Lecture1.html":{"url":"Lecture1.html","title":"Basic C Language","keywords":"","body":"Basic C Language "},"C1.html":{"url":"C1.html","title":"Overview of C","keywords":"","body":"Overview of C "},"C2.html":{"url":"C2.html","title":"Overview constants, Data Types","keywords":"","body":"Data Types Variables Constants Operators Expressions Variables and Constants Variables and constants are the basic data objects manipulated in a program. All variables must be declared before use, although certain declarations can be made implicitly by content. [info] Primative Data Types char        a single byte, capable of holding one character in the local character set int           an integer, typically reflecting the natural size of integers on the host machine float        single-precision floating point double    double-precision floating point [info] signed and unsigned forms Unsigned    target type will have unsigned representation Unsigned char: 0~255 Signed char: -128~127 The max unsigned integer is 2^31 If add two unsigned integer larger than 2^31, it will overflow, results will be mod by 2^32 The max signed integer is 2^32 If add two signed integer larger than 2^31, it will overflow, results will be negative number Signed        target type will have signed representation [warning] String String is not primative data type. String constants would be concatenated at compile time. C uses “array” of chars for storing a string. String must ends with a special character '\\0' char str[] = { 'F', 'o', 'o', 'b', 'a', 'r', '\\0' } You would define a string like, in this way the NULL character is hidden char str[] = “Foobar” You would use a char* “pointer”, in this way the NULL character is hidden char *str = “Foobar” Certain characters can be represented in character and string constants by escape sequences. Escape sequence Character represented Escape sequence Character represented \\a alert character \\\\ backslash \\b backspace \\? question mark \\f formfeed \\' single quote \\n newline \\\" double quote \\r carriage return \\ooo octal number \\t horizontal tab \\xhh hexadecimal number \\v vertical tab Operators and expressions Arithmetic Operators The binary arithmetic operators are addition +, subtraction, - multiplication *, division /, and the modulus operator %. Relational and Logical Operators The relational operators are >, >=, , , ==, and !=. The logical operators are && and ||. Increment and Decrement Operators The increment operator ++ adds 1 to its operand, while the decrement operator -- subtracts 1. These operators can be placed before (prefix) or after (postfix) a variable. Bitwise Operators The bitwise operators are bitwise AND &, bitwise inclusive OR |, bitwise exclusive OR ^, left shift , right shift >>, and one's complement ~. Assignment Operators and Expressions The assignment operator = assigns a value to a variable. Conditional Expressions The conditional expression is (condition_is_true) ? do_if_true : do_if_false;. In the expression expr1 ? expr2 : expr3, the expression expr1 is evaluated first. If it is true, then the expression expr2 is evaluated, and that is the value of the conditional expression. Otherwise expr3 is evaluated, and that is the value. Only one of expr2 and expr3 is evaluated. "},"C3.html":{"url":"C3.html","title":"Conditionals and loops","keywords":"","body":"Conditionals and loops Theif statements The conditional expression The switch statement The loops if statement The syntax is if (condition_is_true) do_something; Sometimes we wish to do more than one thing in response to a condition being true. We would use braces. if (condition_is_true){ do_something; do_something; } Sometimes we wish to have a second conditional statement in response to the first condition being true. It's a good idea to use braces when there are nested ifs. if (condition_is_true) if(condition_is_true){ do_something; } Sometimes we wish to do one thing if a condition is true but another if the condition is false. if (condition_is_true) do_something; else do_something_else; else if statement What happens in the else if statement is that one of the statement is executed, depending on which of the condition is true. Each condition is tested in turn, and if one is true, the corresponding statement is executed, and the rest are skipped. if none of the condition is true, we fall through to the last one. The syntax is if (expression) statement else if (expression) statement else if (expression) statement else if (expression) statement else statement [info] else if statement This sequence of if statements is the most general way of writing a multi-way decision. The expressions are evaluated in order; if an expression is true, the statement associated with it is executed, and this terminates the whole chain. As always, the code for each statement is either a single statement, or a group of them in braces. Conditional expressions Instead of an if else statement, we can use the conditional expression operator: (condition_is_true) ? do_if_true : do_if_false; a = (condition_is_true) ? b : c switch statement An if else statement is used for binary decisions–those with two choices. Sometimes there are more than two choices. The switch statement is a multi-way decision that tests whether an expression matches one of a number of constant integer values, and branches accordingly. switch (expression) { case const-expr: statements case const-expr: statements default: statements } [warning] Notes on the use of the switch statement The labels must be integers. The default line is optional. Once the matching label is found, that statement and each following statement will be executed. Loops 1.while loops There are many occasions in which we don’t know in advance how many times the loop should repeat, but we do know under what conditions the loop should terminate. while(test) { do_something; } 2.for loops for(expression1; expression2; expression3) do_something; [info] expression expression1 initializes the counter. expression2 is the condition for stopping. expression3 is the method of incrementing the counter at the end of the loop. 3.do-while loops The do while loop differs from the while loop in that the body will be visited once before the test is evaluated. do { do_something; } while(test) 4.continue and break We would use continue to jump to the very end of the current loop. We would use break to jump out of the current loop completely. "},"C5.html":{"url":"C5.html","title":"Pointers and arrays","keywords":"","body":"Pointers and arrays Pointers Arrays Multidimensional Arrays Pointers and arrays Pointer Addresses in Memory The address of the variable is stored in the memory. We would use the address operator, an ampersand &, to return its address. The format specifier for address is %p. Number Systems Common Name Base Digits binary 2 01 octal 8 01234567 decimal 10 0123456789 hexadecimal 16 0123456789ABCDEF 3.Pointers A pointer is a variable whose contents are the address of another variable. Let's say that the integer is int number = 3; the content of number is 3 and the address of number is &number. We would create a pointer int *numberPtr; and copy the address of number to the pointer numberPtr = &number. The content of numberPtr is the address of number. We would use the dereference operator, an asterisk *, to modify its locations in memory. Let's say that the integer is int number = 3; and the pointer is int* numberPtr;. We would copy the address of the number to the pointer numberPtr = &number. The content of number is number, which is 3. The content of number using pointer is *numberPtr, which is 3. We would change waht the pointer points to *numberPtr = 6. The content of number will be 6. Pointer numberPtr has its own type, a type of int* or pointer-to-int. We would increment the address in the pointer numberPtr++. Pointers to pointers Pointers can contain the address of another pointer. int number = 5;, int* numberPtr = &number, int** Ptr2 = &numberPtr;. We would compare the addresses stored in pointers if(numberPtr1 == numberPtr2). We would compare the values of the variables that pointers point to if(*numberPtr1 == *numberPtr2). We would initialize the pointer to NULL, int *numberPtr;, numberPtr = NULL. 4.Pointers and Functions Pointers allow us to use a process called pass by reference, in which we will be able to change the value of the original variable. We do this by passing the variable’s address to the function. 5.Arrays of Pointers A pointer is a variable type and we can have an array of pointers just as we have had arrays of other variable types. Array Array is a variable that can hold more than one value. We would define an array of size 10 int a[10]. The array a[10] will hold 10 integer numbers. We could provide the specific array values a[0] = 1, a[1] = 2, etc. We would also declare and initialize the array at the same time int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}. The first element of the array is a[0], the second element is a[1], etc. [info] Array Each element of the array will be of the same type. Array indices began at 0. The initialized values will be at the beginning of the array. The remaining values will be initialized to zero. [warning] Array out of bounds A common error is the “array out of bounds” error that occurs when the index goes beyond the declared size. The value outside the assigned range will be changed. Multidimensional Arrays 2D array int a[rows][columns] = { {1, 2, 3}, {4, 5, 6} }; 3D array int a[][][]; [warning] 1D and 2D arrays differences When declaring a 2D array, the number of columns is required. Pointers and arrays 1.Pointers and arrays are closely linked in C. /*array name evaluates to the address of * the first element in the array*/ #include int main() { int num[4] = {1, 2, 3, 4}; printf(\"The address of num[0] is %p\\n\", num); printf(\"The content of num[0] is %d\\n\", *num); return 0; } [info] Arrays The array name num is the address of the first element, and *num is the content of the first element. /*array name evaluates to the address of * the first element in the array*/ #include int main() { int num[4] = {1, 2, 3, 4}; int* numPtr = num; int* firstPtr = &num[0]; printf(\"The address of num[0] using numPtr is %p\\n\", numPtr); printf(\"The content of num[0] using numPtr is %d\\n\", *numPtr); printf(\"The address of num[0] using firstPtr is %p\\n\", firstPtr); printf(\"The content of num[0] using firstPtr is %d\\n\", *firstPtr); return 0; } [info] Pointers and arrays Let's say that firstPtr is the pointer to the integer num[0], declared as int* firstPtr;. firstPtr = &num[0] is the address of num[0]. *firstPtr is the contents of num[0]. 2.We would increment the address to move through the array. #include int main() { int num[4] = {1, 2, 3, 4}; printf(\"The address of num[1] is %p\\n\", num + 1); printf(\"The content of num[1] is %d\\n\", *(num + 1)); return 0; } #include int main() { int num[4] = {1, 2, 3, 4}; int* numPtr = num; int* firstPtr = &num[0]; printf(\"The address of num[1] using numPtr is %p\\n\", numPtr + 1); printf(\"The content of num[1] using numPtr is %d\\n\", *(numPtr + 1)); printf(\"The address of num[1] using firstPtr is %p\\n\", firstPtr + 1); printf(\"The content of num[1] using firstPtr is %d\\n\", *(firstPtr + 1)); for (int i = 0; i [info] Pointer arithmetic Let's say that firstPtr is the pointer to the integer num[0], declared as int* firstPtr;. firstPtr + i is the address of num[i]. *(firstPtr + i) is the contents of num[i]. #include int main() { char charArray[] = {'a', 'b', 'c', 'd', 'e'}; int intArray[] = {1, 2, 3, 4, 5}; printf(\"charArray intArray\\n\"); printf(\"------------------------------\\n\"); for (int i = 0; i [info] Pointer arithmetic Pointer arithmetic handles the task of determining the address of the next element in the array. 3.Arrays and functions [info] Arrays as function parameters We would pass the address of the first element of an array int num[] = {1, 2, 3}; function(num);. The subscript style of the array as function parameters void function(int data[]){}. The pointer style of the array as function parameters void somefunction(int* data){}. 4.2D Arrays #include int main() { int data[2][3] = {{1, 2, 3}, {6, 7, 8}}; printf(\"The address of data is %p\\n\", data); printf(\"The address of row 0 is %p\\n\", *data); printf(\"The value of the data[0][0] is %d\\n\", **data); return 0; } [info] 2D Arrays Returning the address of any element of any row *(array_name + row) + column. Returning the value of any element of any row *(*(array_name + row) + column). 5.Pointers to 2D arrays #include int main() { int data[2][3] = {{1, 2, 3}, {6, 7, 8}}; int *ptrOne = &data[0][0]; int (*ptrTwo)[3] = data; printf(\"The first element of array is %p\\n\", ptrOne); printf(\"The first element of array is %p\\n\", ptrTwo[0]); return 0; } [info] 2D Arrays We can also create a pointer to a 2D array. The int *ptrOne = &data[0][0]; allows pointer arithmetic based on individual ints. The int (*ptrTwo)[3] = data; allows pointer arithmetic based on row/column values for accessing the array elements. 6.We can have an array whose members are pointers. 7.The typical use for arrays of pointers is not with numeric types, such as int or double, but with strings. "},"C6.html":{"url":"C6.html","title":"Strings","keywords":"","body":"Strings char ASCII Strings char A char is a one byte integer type typically used for storing characters. char letter = 'A'; [info] Character We enclose the character in single quotes, not double quotes. ASCII Plain text is often stored in a format called ASCII. char letter = 'a'; char decimal = 97; The letters A–Z have ASCII values of 65–90 while a–z have values of 97–122. char uppercase = 'A'; char lowercase; lowercase = uppercase + 32; Strings C does not have a string type. Instead, we use an array of chars for storing a string. char str[] = { 'F', 'o', 'o', 'b', 'a', 'r', '\\0' } char myName[] = \"foobar\"; char *myName = \"foobar\"; "},"C4.html":{"url":"C4.html","title":"Functions and program structure","keywords":"","body":"Functions and program structure Functions Each function definition has the general form return_type function_name(input_type variable_name) { /* something happens here */ } int addNumbers(int number1, int number2) { int sum = number1 + number2; return sum; } [info] Functions Variable The variable names in the function definition do not have to match the names in the function call. We would declare variables in our function. We would call other functions in our function. Return We would use return keyword to return a value. We would use void if we are not passing or not returning anything. We can pass or receive any types of variables. Arrays We can pass arrays to functions just as we do with other variable types. There is a significant difference between passing variables to functions and passing arrays to functions. When passing a cariable by value, a copy of the variable is used in the function. The changes to the variables will not affect the original. When passing an array to a function, we are actually passing the address of the array. The changes to the array will affect the original. When passing 2D arrays as paramerters, the number of the columus is required. Declarations Function code would be before main. Function declaration would be before main. Including functions To use functions in the Standard C Library stdio.h. We could place our own functions in their own file and use them in our programs Variable scope Scope Visibility of variable. Local variable Variables declared within a function block are local variables and they are known only to that function. Variables declared outside the function are unknown to the function. Global variable A global variable is a variable that is declared outside all functions. A global variable can be used in all functions. "}}